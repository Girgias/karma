#!/usr/bin/env php
<?php
/*
 * The PHP.net KARMA hook. For git repositories.
 *
 * (c) 2011 David Soria Parra <dsp at php dot net>
 *
 * Licensed under the terms of the MIT license.
 */
namespace Karma;

const KARMA_FILE = '/repository/checkout/SVNROOT/global_avail';

set_include_path('/repository/checkout/karma/lib' .
    PATH_SEPARATOR .
    get_include_path());

include 'Git/ReceiveHook.php';

function deny($reason)
{
    fwrite(STDERR, $reason . "\n");
    exit(1);
}

function accept($message)
{
    fwrite(STDOUT, $message . "\n");
    exit(0);
}

function get_karma_for_paths($username, array $paths, array $avail_lines)
{
    $access = array_fill_keys($paths, 'unavail');
    foreach ($avail_lines as $acl_line) {
        $acl_line = trim($acl_line);
        if ('' === $acl_line || '#' === $acl_line{0}) {
            continue;
        }

        @list($avail, $user_str, $path_str) = explode('|', $acl_line);

        $allowed_paths = explode(',', $path_str);
        $allowed_users = explode(',', $user_str);

        /* ignore lines which don't contain our users or apply to all users */
        if (!in_array($username, $allowed_users) && !empty($user_str)) {
            continue;
        }

        if (!in_array($avail, ['avail', 'unavail'])) {
            continue;
        }

        if (empty($path_str)) {
            $access = array_fill_keys($paths, $avail);
        } else {
            foreach ($access as $requested_path => $is_avail) {
                foreach ($allowed_paths as $path) {
                    if (fnmatch($path . '*', $requested_path)) {
                        $access[$requested_path] = $avail;
                    }
                }
            }
        }
    }

    return $access;
}

function get_unavail_paths($username, array $paths, array $avail_lines)
{
    return
        array_keys(
            array_filter(
                get_karma_for_paths($username, $paths, $avail_lines),
                function ($avail) {
                    return 'unavail' === $avail;
                }));
}


error_reporting(E_ALL | E_STRICT);
date_default_timezone_set('UTC');
putenv("PATH=/opt/bin:/usr/local/bin:/usr/bin:/bin");
putenv("LC_ALL=en_US.UTF-8");

$hook            = new \Git\ReceiveHook();
$requested_paths = $hook->getReceivedPaths();

if (empty($requested_paths)) {
    deny("We cannot figure out what you comitted!");
}

if (isset($_ENV['REMOTE_USER'])) {
    $user = $_ENV['REMOTE_USER'];
} else if (isset($_ENV['HTTP_AUTHORIZATION'])) {
    /* hacky hack is hacky */
    $auth  = $_ENV['HTTP_AUTHORIZATION'];
    $basic = base64_decode(explode(' ', $auth)[1]);
    $user  = explode(':', $basic)[0];
} else if (isset($_ENV['SSH_CONNECTION'])) {
    $user = $_ENV['USER'];
}

fprintf(STDOUT, "Welcome $user.\n");

$prefix          = sprintf('%s/', $hook->getRepositoryName());
$avail_lines     = $hook->getKarmaFile();
$requested_paths = array_map(function ($x) use ($prefix) { return $prefix . $x;}, $requested_paths);
$unavail_paths   = get_unavail_paths($user, $requested_paths, $avail_lines);

if (!empty($unavail_paths)) {
    deny(sprintf(
        "You have insufficient Karma!\n" .
        "I'm sorry, I cannot allow you to write to\n" .
        "    %s\n" .
        "Have a nice day.",
        implode("\n    ", $unavail_paths)));
}

accept("Changesets accepted. Thank you for your contribution.");
